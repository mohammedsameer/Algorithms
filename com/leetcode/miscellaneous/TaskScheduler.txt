//Algo:
//1. Keep track of maxTaskCount and number of such maxTasks
//2. partCount = maxTaskCount - 1
//3. partLength = n-(numberOfMaxTasks-1)
//4. emptySlots = partCount * partLength
//5. availableTasks = totalTasks - ( numberOfMaxTasks * maxTaskCount) //aka remove already placed tasks
//6. idleTasks = Math.max(0,  emptySlots - availableTasks)
//7. result = totalTasks + idleTasks
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] taskArr = new int[26];
        
        int maxTaskCount = 0;
        int numOfMaxTaskCount = 0;
        
        for(char task : tasks) {
            taskArr[task-'A']++;
            
            if(maxTaskCount < taskArr[task-'A']) {
                //We found our single most frequent task
                maxTaskCount = taskArr[task-'A'];
                numOfMaxTaskCount = 1;
            } else if (maxTaskCount == taskArr[task-'A']) {
                //We found another task with same maxtaskCount
                numOfMaxTaskCount++;
            }
        }
        
        //Number of parts b/w task with max count
        int partCount = maxTaskCount - 1;
        //Number of actual slots b/w tasks with max count
        int partLength = n - (numOfMaxTaskCount - 1);
        int emptySlots = partCount * partLength;
        //Remaining tasks = Total tasks - maxcount tasks
        int availableTasks = tasks.length - (numOfMaxTaskCount * maxTaskCount); 
        //Empty slots - all ramaining tasks
        //Note: When 3A, 3B with n=2, no empty slots are needed, hence Math.max(0, <>)
        int idleTasks = Math.max(0, emptySlots - availableTasks); 
        //All tasks + idle tasks in between
        return tasks.length + idleTasks;
    }
}