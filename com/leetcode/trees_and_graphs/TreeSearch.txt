package com.leetcode;


import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * TreeSearch
 * Algorithm
 * 1. Use start node and look for its adjacents
 * 2. Compare adjacents for matching
 * Note: Always mark the node to avoid cycling through the graph
 */
class Program {

    public enum State {
        VISITED, UNVISITED;
    }

    public class Graph {
        Node root;
    }

     public class Node {
        int data;
         Node left;
         Node right;
         State state = State.UNVISITED;
         Node(int data) {
            this.data = data;
        }
         public List<Node> getAdjacent() {
            List<Node> nodes = new ArrayList<>();
            if(this.left != null)
                nodes.add(left);
            if(this.right != null)
                nodes.add(right);

            return nodes;
         }
    }


    public boolean search(Node start, Node end) {
        if(start == null || end == null)
            return false;

        Stack<Node> stack = new Stack<>();
        //Assumes all nodes are marked as unvisited
        stack.push(start);
        while (!stack.isEmpty()) {
            Node next = stack.pop();
            next.state = State.VISITED;
            while(next != null) {
                for(Node node : next.getAdjacent()) {
                    if (node.state == State.UNVISITED) {
                        //The above check ensure we dont re-add previously visited nodes on stack
                        if (node.data == end.data) {
                            return true;
                        } else {
                            node.state = State.VISITED;
                            stack.push(node);
                        }
                    }
                }
                next = stack.pop();
            }
        }

        return false;
    }
}