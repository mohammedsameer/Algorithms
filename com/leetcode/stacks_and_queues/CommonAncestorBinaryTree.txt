package com.leetcode;


Solution-1
/**
 * Algorithm
 * 1. Check if both nodes are in left subtree, if yes then recurse left subtree
 * 2. Check if both nodes are in right subtree, if yes then recurse left subtree
 */
class Program {

     public class Node {
        int data;
         Node left;
         Node right;
         Node parent;
         Node(int data) {
            this.data = data;
        }
    }

    private Node commonAncestor(Node root, Node p, Node q) {
         if(root == null)
             return null;

         if(covers(root.left, p) && covers(root.left, q)) {
             return commonAncestor(root.left, p, q);
         }

        if(covers(root.right, p) && covers(root.right, q)) {
            return commonAncestor(root.right, p, q);
        }

        return root;
    }

    private boolean covers(Node root, Node curr) {
         if(root == null) return false;
         if(root == curr) return true;
         return covers(root.left, curr) || covers(root.right, curr);
    }

}


Solution-2

import java.util.List;

/**
 * Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree.
 * Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a binary search tree.
 * Algorithm
 * 1. Traverse from root to n1
 * 2. Traverse from root to n2
 * 3. Compare the path lists to until the mismatch and return the last matched element
 */
class Program {

     public class Node {
        int data;
         Node left;
         Node right;
         Node parent;
         Node(int data) {
            this.data = data;
        }
    }


    public boolean traverse(Node root, Node curr, List<Node> path) {
         if(root == null)
             return false;

         path.add(root);

         if(root.data == curr.data) {
             return true;
         }

         //Recursive left subtree
         if(root.left != null && traverse(root.left, curr, path)) {
             return true;
         }

         //Recurse right subtree
         if(root.right != null && traverse(root.right, curr, path)) {
             return true;
         }

        // Remove current node as it did not yield a path
        path.remove(path.size() -1);
        return false;
    }
}



