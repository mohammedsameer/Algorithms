package com.leetcode;

import java.util.*;

class Program {

    public static List<Integer> stack = new ArrayList<>();
    public static List<Integer> minStack = new ArrayList<>();

    public static void push(int val)
    {
        //Always add on primary stack
        stack.add(val);

        if(minStack.isEmpty()) {
            minStack.add(val);
        }
        else
        {
            if(getMin()>val)
                minStack.add(val);
        }
    }

    public static int pop()
    {
        int result = -1;
        if(!stack.isEmpty())
        {
            result = stack.remove(stack.size() - 1);
            if(getMin() == result)
            {
                minStack.remove(minStack.size() -1);
            }
        }

        return result;
    }

    public static int getMin()
    {
        int result = -1;
        if(!minStack.isEmpty()) {
            result = minStack.get(minStack.size()-1);
        }

        return result;
    }


    public static void main(String[] args) {

        //Add ontop of stack
        Program.push(10);
        Program.push(20);
        Program.push(-30);
        System.out.println("The min element:"+ Program.getMin());

    }
}


//Solution-2 (Multiple stacks)
package com.leetcode;

/**
 * How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element?
 * Push, pop and min should all operate in O(1) time
 */

//Solution1 - Multistack implementation
public class Program {

    public class Node {
        int data;
        Node next;
        Node(int data) {
            this.data = data;
        }
    }

    //Basic stack implementation
    public class Stack {
        Node top;
        public void push(int data) {
            if(top != null) {
                Node node = new Node(data);
                node.next = top;
                top = node;
            } else {
                top = new Node(data);
            }
        }

        public int pop() {
            if(!isEmpty()) {
                int data = top.data;
                top = top.next;
                return data;
            }
            return -1;
        }

        public int peek() {
            if(!isEmpty()) {
                return top.data;
            }
            return -1;
        }
        public boolean isEmpty() {
            return top == null;
        }
    }

    //Min stack implementation
    public class StackMin extends Stack {
        Node top;
        public void push(int data) {
            if(data < min()) {
                top.data = data;
            }
            super.push(data);
        }

        public int pop() {
            int data = super.pop();
            if(data == min()) {
                top = top.next;
            }
            return data;
        }

        public int min() {
            if(!isEmpty()) {
                return top.data;
            }
            return -1;
        }
    }
}